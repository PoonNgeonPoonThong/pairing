<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY rfc1033 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1033.xml'>
<!ENTITY rfc1034 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1034.xml'>
<!ENTITY rfc1035 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1035.xml'>
<!ENTITY rfc2045 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2045.xml'>
<!ENTITY rfc2104 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2104.xml'>
<!ENTITY rfc2119 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml'>
<!ENTITY rfc2782 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2782.xml'>
<!ENTITY rfc4055 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4055.xml'>
<!ENTITY rfc4075 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4075.xml'>
<!ENTITY rfc4279 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4279.xml'>
<!ENTITY rfc5246 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml'>
<!ENTITY rfc5705 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5705.xml'>
<!ENTITY rfc5246 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml'>
<!ENTITY rfc6124 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6124.xml'>
<!ENTITY rfc6151 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6151.xml'>
<!ENTITY rfc6189 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6189.xml'>
<!ENTITY rfc6762 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6762.xml'>
<!ENTITY rfc6763 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6763.xml'>
<!ENTITY rfc7296 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7296.xml'>
<!ENTITY rfc7626 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7626.xml'>
<!ENTITY rfc7844 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7844.xml'>
<!ENTITY rfc7858 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7858.xml'>

<!ENTITY I-D.ietf-dnssd-privacy PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dnssd-privacy.xml">


<!ENTITY I-D.ietf-dnssd-pairing PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dnssd-pairing.xml">


<!ENTITY I-D.ietf-intarea-hostname-practice PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-intarea-hostname-practice.xml">
<!ENTITY I-D.ietf-dprive-dnsodtls PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dprive-dnsodtls.xml">
<!ENTITY I-D.ietf-tls-tls13 PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-tls-tls13.xml">
<!ENTITY I-D.ietf-dnssd-push PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dnssd-push">
<!ENTITY I-D.miers-tls-sas PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.miers-tls-sas">


<!ENTITY kw14a PUBLIC ''
   "references/reference.kw14a.xml">
<!ENTITY kw14b PUBLIC ''
   "references/reference.kw14b.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc compact="yes"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>

<!-- Expand crefs and put them inline -->
<?rfc comments='yes' ?>
<?rfc inline='yes' ?>

<rfc category="info"
     docName="draft-ietf-dnssd-pairing-info-00"
     ipr="trust200902">

<front>
    <title abbrev="Device Pairing Issues">
      Device Pairing Design Issues
    </title>


   <author fullname="Daniel Kaiser" initials="D." surname="Kaiser">
     <organization>University of Konstanz</organization>
      <address>
        <postal>
          <street> </street>
          <city>Konstanz</city>
          <code>78457</code>
          <region></region>
          <country>Germany</country>
        </postal>
        <email>daniel.kaiser@uni-konstanz.de</email>
      </address>
    </author>

   <author fullname="Christian Huitema" initials="C." surname="Huitema">
      <organization>Private Octopus Inc.</organization>
      <address>
        <postal>
          <street> </street>
          <city>Friday Harbor</city>
          <code>98250</code>
          <region>WA</region>
          <country>U.S.A.</country>
        </postal>
        <email>huitema@huitema.net</email>
      </address>
    </author>
    <date year="2017" />

    <abstract>
        <t>
          This document discusses issues and problems occuring in the design of device pairing mechanism.
          It presents experience with existing pairing systems and general user interaction requirements
          to make the case for "short authentication strings". It then reviews the design of 
          cryptographic algorithms designed to maximise the robustness of the short authentication
          string mechanisms, as well as implementation considerations such as integration with TLS.
        </t>
    </abstract>
</front>

<middle>
<section title="Introduction" anchor="intro" >
  <t>
  To engage in secure and privacy preserving communication, hosts need to differentiate
  between authorized peers, which must both know about the host's presence and be able to decrypt messages sent by the host,
  and other peers, which must not be able to decrypt the host's messages and ideally should  not be aware of the host's presence.
  The necessary relationship between host and peer can be established by a centralized service, e.g. a certificate  authority,
  by a web of trust, e.g. PGP, or -- without using global identities -- by device pairing.
  </t>
  <t>
The general pairing requirement is easy to state: establish a trust relation between two entities in a 
secure manner. But details matter, and in this section we explore the detailed requirements that 
will guide the design of a pairing protocol.
</t>
 <t>
This document does not specify an actual pairing protocol, but it served as the basis for
the design of the pairing protocol developed for DNS-SD privacy <xref target="I-D.ietf-dnssd-pairing"/>.
</t>
<section title="Document Organization" >
<t>
NOTE TO RFC EDITOR: remove or rewrite this section before publication.
</t>
<t>
This document results from a split of an earlier pairing draft that contained two parts. 
The first part, presented the pairing need, and the list of requirements that shall be met. 
The second part presented the design is the actual specification of the protocol. 
</t>
<t>
In his early review, Steve Kent observed that the style of the first part seems inappropriate for a standards track document,
and suggested that the two parts should be split into two documents, the first part becoming an 
informational document, and the second focusing on standard track specification of the protocol, 
making reference to the informational document as appropriate.
</t>
<t>
The working group approved this split.
</t>
</section>

</section> <!-- end of introduction -->

<section title="Protocol Independent Secure Pairing" anchor="securityReq" >
<t>
Many pairing protocols have already been developed, in particular for the
pairing of devices over specific wireless networks. For example, the current Bluetooth 
specifications include a pairing protocol that has evolved over several
revisions towards better security and usability <xref target="BTLEPairing" />.
The Wi-Fi Alliance defined the Wi-Fi Protected Setup process to ease the setup of 
security-enabled Wi-Fi networks in home and small office environments 
<xref target="WPS" />. Other wireless standards have defined or are defining similar
protocols, tailored to specific technologies.
</t>
<t>
  In this document we provide background and discuss the design of a manually authenticated pairing protocol
  that is independent of the underlying network protocol stack.
  We discuss (1) means allowing  the two parties engaged in the pairing
  to discover each other in an existing unsecured network -- e.g. means for learning about 
  the network parameters of the respective other device --
  which allows them to establish a connection;
  (2) agreeing on a shared secret via this connection; and (3)
  manually authenticating this secret.

  For our discussion and our secure pairing protocol specification <xref target="I-D.ietf-dnssd-pairing"/>,
  we assume an IP based unsecured network.
  With little adaption, this pairing mechanism can be used on other protocol stacks as well.
</t>
<t>
<!-- TODO: Should we discuss certificates besides a shared secret? -->
We limit the goal of the protocol to the establishment of a shared secret between two
parties. Once that secret has been established, it can trivially be used to secure the exchange
of other informations, such as for example public keys and certificates.
</t>
</section>

<section title="Identity Assurance" anchor="verifyId">
<t>
The parties in the pairing must be able to identify each other. To put it simply, if Alice believes 
that she is establishing a pairing with Bob, she must somehow ensure that the pairing is actually
established with Bob, and not with some interloper like Eve or Nessie.
Providing this assurance requires designing both the protocol and the user interface (UI) with care.
</t>
<t>
Consider for example an attack in 
which Eve tricks Alice into engaging in a pairing process while pretending to be Bob. Alice must be able 
to discover that something is wrong, and refuse to establish the pairing.
The parties engaged in the pairing must at least be able to verify their identities, respectively.
</t>
</section>

<section title="Manual Authentication" anchor="MITMUIReq" >
<t>
Because the pairing protocol is executed without prior knowledge, it is typically vulnerable to
"Man-in-the-Middle" attacks. While Alice is trying to establish a pairing with Bob, Eve positions 
herself in the middle. Instead of getting a pairing between Alice and Bob, both Alice and Bob get
paired with Eve. Because of this, the protocol requires specific features to
detect Man-in-the-Middle attacks, and if possible resist them.
</t>

<t>
This section discusses existing techniques that are used in practice for manually authenticating a Diffie-Hellman key exchange,
and <xref target="MITMCryptoReq" /> provides a layman description of the MiTM problem and countermeasures.
A more in depth exploration of manually authenticated pairing protocols may be found in <xref target="NR11" />
and <xref target="K17" />.
</t>

<section title="Short PIN Proved Inadequate" >
<t>
The initial Bluetooth pairing protocol relied on a four digit PIN, displayed by one of the devices to be paired.
The user read that PIN and provided it to the other device.
The PIN was then used in a Password Authenticated Key Exchange.
Wi-Fi Protected Setup <xref target="WPS" /> offered a similar option.
There were various attacks against the actual protocol; some of the problems were caused by issues
in the protocol, but most were tied to the usage of short PINs.
</t>
<t>
In the reference implementation, the PIN is picked at random by the paired device before
the beginning of the exchange. But this requires that the paired device is capable of
generating and displaying a four digit number. It turns out that many devices cannot do
that. For example, an audio headset does not have any display capability. These limited
devices ended up using static PINs, with fixed values like "0000" or "0001".
</t>
<t>
Even when the paired device could display a random PIN, that PIN had to be copied
by the user on the pairing device. It turns out that users do not like copying long
series of numbers, and the usability thus dictated that the PINs be short -- four digits
in practice. But there is only so much assurance as can be derived from a four digit key.
</t>
<t>
The latest revisions of the Bluetooth Pairing protocol 
<xref target="BTLEPairing" /> do not include the short PIN option anymore. The 
PIN entry methods have been superseded by the simple "just works" method for devices
without displays, and by a procedure based on an SAS (short authentication string) when
displays are available.
</t>

<t>
A further problem with these PIN based approaches is that -- in contrast to SASes --
the PIN is a secret instrumental in the security algorithm.
To guarantee security, this PIN would have to be transmitted via a secure out-of-band channel.
</t>

</section>

<section title="Push Buttons Just Work, But Are Insecure" >
<t>
Some devices are unable to input or display any code. The industry more or less
converged on a "push button" solution. When the button is pushed, devices enter
a "pairing" mode, during which they will accept a pairing request from whatever 
other device connects to them.
</t>
<t>
The Bluetooth Pairing protocol <xref target="BTLEPairing" /> denotes that as 
the "just works" method. It does indeed work, and if the pairing succeeds
the devices will later be able to use the pairing keys to authenticate connections.
However, the procedure does not provide any protection against
MitM attacks during the pairing process. The only protection is that pushing the
button will only allow pairing for a limited time, thus limiting the
opportunities of attacks.
</t>
<t>
As we set up to define a pairing protocol with a broad set of applications,
we cannot limit ourselves to an insecure "push button" method. But we probably
need to allow for a mode of operation that works for input-limited
and display limited devices.
</t>
</section>
<section title="Short Range Communication" anchor="shortRange" >
<t>
Many pairing protocols that use out-of-band channels have been defined.
Most of them are based on short range communication systems,
where the short range limits the feasibility for attackers to access the channels.
Example of such limited systems include for example:
</t>
<t>
<list style="symbols" >
<t>
QR codes, displayed on the screen of one device, and read by the camera of the other device.
</t>
<t>
Near Field Communication (NFC) systems, which provides wireless communication with a very short range.
</t>
<t>
Sound systems, in which one systems emits a sequence of sounds or ultrasounds that is picked by the microphone of the other system.
</t>
</list>
</t>
<t>
A common problem with these solutions is that they require special capabilities that may not be present in every device. 
Another problem is that they are often one-way channels.
</t>
<t>
  The pairing protocols should not rely on the secrecy of the out-of-band channels; most of these
  out-of-band channels do not provide confidentiality.
QR codes could be read by third parties. Powerful radio antennas might be able to interfere with 
NFC. Sensitive microphones might pick the sounds.
However, a property that all of these channels share
is authenticity, i.e. an assurance that the data obtained over the out-of-band channel actually comes from the other party.
This is because these out-of-band channels involve the user transmitting information from one device to the other.
We will discuss the specific case of QR codes in <xref target="QRDiscuss" />.
</t>
</section>

<section title="Short Authentication Strings" >
<t>
The evolving pairing protocols seem to converge towards using Short Authentication Strings and
verifying them via the "compare and confirm" method. 
This is in line with academic studies, such as <xref target="KFR09" /> or <xref target="USK11" />,
and, from the users' perspective, results in a very simple interaction:
</t>
<t>
<list style="numbers">
<t>
Alice and Bob compare displayed strings that represent a fingerprint of the afore exchanged pairing key.
</t>
<t>
If the strings match, Alice and Bob accept the pairing.
</t>
</list>
</t>
<t>
Most existing pairing protocols display the fingerprint of the key as a 6 or 7 digit
number. Usability studies show that this method gives good results, with little risk that
users mistakenly accept two different numbers as matching. However, the authors of 
<xref target="USK11" /> found that people had more success comparing computer 
generated sentences than comparing numbers. This is in line with the argument in
<xref target="XKCD936" /> to use sequences of randomly chosen common words as passwords. 
On the other hand, standardizing strings is more complicated than standardizing numbers.
We would need to specify a list of common words, and the process to go from a binary 
fingerprint to a set of words. We would need to be concerned with internationalization 
issues, such as using different lists of words in German and in English. This could
require the negotiation of word lists or languages inside the pairing protocols. 
</t>
<t>
In contrast, numbers are easy to specify, as in "take a 20 bit number and 
display it as an integer using decimal notation".
</t>

</section>

</section>

<section title="Resist Cryptographic Attacks" anchor="MITMCryptoReq" >
<t>
It is tempting to believe that once two peers are connected, they could create
a secret with a few simple steps, such as for example (1) exchange two nonces, 
(2) hash the concatenation of these nonces with the shared secret that is about to be established, (3) display
a short authentication string composed of a short version of that hash 
on each device, and (4) verify that the two values match.
This naive approach might yield the following sequence of messages:

</t>
<t>
<figure>
<artwork>
    Alice                       Bob
    g^xA --&gt;
                           &lt;-- g^xB
    nA --&gt;
                              &lt;-- nB
    Computes              Computes
    s = g^xAxB            s = g^xAxB
    h = hash(s|nA|nB)     h = hash(s|nA|nB)
    Displays short        Displays short
    version of h          version of h
</artwork>
</figure>
</t>
<t>
If the two short hashes match, Alice and Bob are supposedly assured that
they have computed the same secret, but there is a problem.
<!-- The exchange may not deter a smart attacker in the middle. -->
Let's redraw the same message flow, this time involving the attacker Eve:
</t>
<t>
<figure>
<artwork>
    Alice                Eve                Bob
    g^xA --&gt;
                         g^xA'--&gt;
                                        &lt;-- g^xB
                      &lt;--g^xB'
    nA --&gt;
                         nA --&gt; 
                                          &lt;-- nB
                       Picks nB'
                       smartly
                      &lt;--nB'
    Computes                             Computes
    s' = g^xAxB'                           s" = g^xA'xB
    h' = hash(s'|nA|nB')                    h" = hash(s"|nA|nB)
    Displays short                       Displays short
    version of h'                        version of h"
</artwork>
</figure>
</t>
<t>
  In order to pick a nonce nB' that circumvents this naive security measure,
  Eve runs the following algorithm:
</t>
<t>
<figure>
<artwork>
    s' = g^xAxB'
    s" = g^xA'xB
    repeat
       pick a new version of nB'
       h' = hash(s'|nA|nB')
       h" = hash(s"|nA|nB)
    until the short version of h' 
    matches the short version of h"
</artwork>
</figure>
</t>
<t>
Running this algorithm will take O(2^b) iterations on average (assuming a uniform distribution), where b is the bit length of the SAS.
Since hash algorithms are fast, it is possible to try millions of values in less than a second.
If the short
string is made up of fewer than 6 digits, Eve will find a matching nonce 
quickly, and Alice and Bob will hardly notice the delay. Even if the 
matching string is as long as 8 letters, Eve will probably find a value
where the short versions of h' and h" are close enough, e.g. start and end
with the same two or three letters. Alice and Bob may well be fooled.
</t>

<t>
  Eve could also utilize the fact that she may freely choose the whole input for the hash function and thus
  choose g^xA' and g^xB' so that an arbitrary collision (birthday attack) instead of a second preimage is
  sufficient for fooling Alice and Bob.
</t>

<t>
The classic solution to such problems is to "commit" a possible attacker to a nonce before sending it.
This commitment can be realized by a hash.
In the modified exchange, Alice sends a secure
hash of her nonce before sending the actual value:
</t>
<t>
<figure>
<artwork>
    Alice                       Bob
    g^xA --&gt;
                            &lt;-- g^xB

    Computes              Computes
    s = g^xAxB            s = g^xAxB
    h_a = hash(s|nA) --&gt;
                              &lt;-- nB
    nA --&gt;
                          verifies h_a == hash(s|nA)
    Computes              Computes
    h = hash(s|nA|nB)     h = hash(s|nA|nB)
    Displays short        Displays short
    version of h          version of h
</artwork>
</figure>
</t>
<t>
Alice will only disclose nA after
having confirmation from Bob that hash(nA) has been received.
At that point, Eve has a problem. She can still forge the values of the nonces,
but she needs to pick the nonce nA' before the actual value of nA has been
disclosed.
Eve would still have a random chance of fooling Alice and Bob, but it will be a very
small chance: one in a million if the short authentication string is made of
6 digits, even fewer if that string is longer. 
</t>
<t>
Nguyen et al. <xref target="NR11" /> survey these protocols and compare them with respect to the amount of necessary user interaction and
  the computation time needed on the devices.
  The authors state that such a protocol is optimal with respect to user interaction if it suffices for users to verify a single b-bit SAS
  while having a one-shot attack success probability of 2^-b.
  Further, n consecutive attacks on the protocol must not have a better success probability then n one-shot attacks.
</t>
<t>
There is still a theoretical problem, if Eve has somehow managed to 
"crack" the hash function.
We can build "defense in depth" by some simple measures.
In the design presented above, the hash "h_a"
depends on the shared secret "s", which acts as a "salt" and reduces
the effectiveness of potential attacks based on pre-computed 
catalogs. The simplest design uses a concatenation 
mechanism, but we could instead use a keyed-hash message authentication 
code (HMAC <xref target="RFC2104"/>, <xref target="RFC6151"/>), using 
the shared secret as a key, since the HMAC construct has
proven very robust over time. Then, we can constrain the size of
the random numbers to be exactly the same as the output of the hash 
function. Hash attacks often require padding the input string with
arbitrary data; restraining the size limits the likelyhood of such 
padding.
</t>
</section>

<section title="Privacy Requirements" >
<t>
Pairing exposes a relation between several devices and their owners. Adversaries may
attempt to collect this information, for example in an attempt to track 
devices, their owners, or their social graph. It is often argued that
pairing could be performed in a safe place, from which adversaries are assumed 
absent, but experience shows that such assumptions are often misguided.
It is much safer to acknowledge the privacy issues and design the pairing
process accordingly.
</t>
<t>
In order to start the pairing process, devices must first discover each other.
We do not have the option of using the private discovery protocol <xref target="I-D.ietf-dnssd-privacy" /> 
since the privacy of that protocol depends on a pre-existing pairing. 
In the simplest design, one of the devices will announce a user-friendly name using DNS-SD. 
Adversaries could monitor the discovery protocol, and record that name.
An alternative would be for one device to announce a random name, and communicate
it to the other device via some private channel. There is an obvious
tradeoff here: friendly names are easier to use but less private than
random names. We anticipate that different users will choose different
tradeoffs, for example using friendly names if they assume that
the environment is safe, and using random names in public places.
</t>
<t>
During the pairing process, the two devices establish a connection
and validate a pairing secret. As discussed in <xref target="MITMUIReq" />,
we have to assume that adversaries can mount MitM attacks. The pairing 
protocol can detect such attacks and resist them, but the attackers will
have access to all messages exchanged before the validation
is performed. It is important to not exchange any privacy sensitive information
before that validation. This includes, for example, the identities of the
parties or their public keys.
</t>

</section>

<section title="Using TLS" >
<t>
The pairing algorithms typically combine the establishment of a shared
secret through an [EC]DH exchange with the verification of that secret
through displaying and comparing a "short authentication string" (SAS).
As explained in <xref target="MITMCryptoReq" />, the
secure comparison requires a "commit before disclose" mechanism.
</t>
<t>
We have three possible designs: (1) create a pairing algorithm from scratch,
specifying our own cryptographic protocol; (2) use an [EC]DH version of TLS to
negotiate a shared secret, export the key to the application as specified 
in <xref target="RFC5705" />, and implement
the "commit before disclose" and SAS verification as part of the pairing
application; or, (3) use TLS, integrate the "commit before disclose" and SAS
verification as TLS extensions, and export the verified key to the
application as specified 
in <xref target="RFC5705" />.
</t>
<t>
When faced with the same choice, the designers of ZRTP <xref target="RFC6189" />
chose to design a new protocol integrated in the general framework of real
time communications. We don't want to follow that path, and would rather not
create yet another protocol. We would need to
reinvent a lot of the negotiation capabilities that are part of TLS, not
to mention algorithm agility, post quantum, and all that sort of things. 
It is thus pretty clear that we should use TLS.
</t>
<t>
It turns out that there was already an attempt to define 
SAS extensions for TLS (<xref target="I-D.miers-tls-sas" />). 
It is a very close match
to our third design option, full integration of SAS in TLS,
but the draft has expired, and there does not seem to be
any support for the SAS options in the common TLS packages.
</t>
<t>
In our design, we will choose the middle ground option -- use TLS for
[EC]DH,
and implement the SAS verification as part of the pairing application.
This minimizes dependencies on TLS packages to the availability
of a key export API following <xref target="RFC5705" />.
We will need to specify the hash algorithm used for the SAS
computation and validation, which carries some of the issues
associated with "designing our own crypto". One
solution would be to use the same hash algorithm negotiated by
the TLS connection, but common TLS packages do not always 
make this algorithm identifier available
through standard APIs. A fallback solution is to
specify a state of the art keyed MAC algorithm.
</t>
</section>

<section title="QR codes" anchor="QRDiscuss" >
<t>
In <xref target="shortRange" />, we reviewed a number of short range 
communication systems that can be used to facilitate pairing. Out of these,
QR codes stand aside because most devices that can display a short
string can also display the image of a QR code, and because many
pairing scenarios involve cell phones equipped with cameras capable of
reading a QR code.
</t>
<t>
QR codes are displayed as images. An adversary equipped with powerful cameras 
could read the QR code just as well as the pairing parties. If the pairing
protocol design embedded passwords or pins in the QR code, adversaries could
access these data and compromise the protocol. On the other hand, there are ways
to use QR codes even without assuming secrecy.
</t>
<t>
QR codes could be used at two of the three stages of pairing: Discovering the peer device, 
and authenticating the shared secret. Using QR codes provides advantages in both phases:
</t>
<t>
<list style="symbols" >
<t>
Typical network based discovery involves interaction with two devices. The device to be discovered
is placed in "server" mode, and waits for requests from the network. The device performing the
discovery retrieves a list of candidates from the network. When there is more than one such 
candidate,
the device user is expected to select the desired target from a list.
In QR code mode, the discovered device will display a QR code, which the user will scan 
using the second device.
The QR code will embed the device's name, its IP address, and the port number of the 
pairing service. The connection will be automatic, without relying on the network discovery.
This is arguably less error-prone and safer than selecting from a network provided list.
</t>
<t>
SAS based agreement involves displaying a short string on each device's display, and asking the
user to verify that both devices display the same string. In QR code mode, one device could 
display a QR code containing this short string. The other device could scan it and compare
it to the locally computed version.
Because the procedure is automated, there is no dependency on the user diligence at 
comparing the short strings.
</t>
</list>
</t>
<t>
Offering QR codes as an alternative to discovery and agreement is straightforward.
If QR codes are used, the pairing program on the server side might display something like:
</t>
<t>
<figure>
<artwork>
   Please connect to "Bob's phone 359"
   or scan the following QR code:

    mmmmmmm  m  m mmmmmmm 
    # mmm # ## "m # mmm # 
    # ### # m" #" # ### # 
    #mmmmm# # m m #mmmmm# 
    mm m  mm"## m mmm mm  
    " ##"mm m"# ####"m""# 
    #"mmm mm# m"# ""m" "m 
    mmmmmmm #mmm###mm# m  
    # mmm #  m "mm " "  " 
    # ### # " m #  "## "# 
    #mmmmm# ### m"m m  m  

</artwork>
</figure>
</t>
<t>
If Alice's device is capable of reading the QR code, it will just
scan it, establishes a connection, and run the pairing protocol. 
After the protocol messages have been exchanged, Bob's device
will display a new QR code, encoding the hash code that should be
matched. The UI might look like this:
</t>
<t>
<figure>
<artwork>
   Please scan the following QR code,
   or verify that your device displays
   the number: 388125

    mmmmmmm   mmm mmmmmmm 
    # mmm # ""#m# # mmm # 
    # ### # "#  # # ### # 
    #mmmmm# # m"m #mmmmm# 
    mmmmm mmm" m m m m m  
     #"m mmm#"#"#"#m m#m  
    ""mmmmm"m#""#""m #  m 
    mmmmmmm # "m"m "m"#"m 
    # mmm # mmmm m "# #"  
    # ### # #mm"#"#m "    
    #mmmmm# #mm"#""m "m"  

   Did the number match (Yes/No)?
</artwork>
</figure>
</t>
<t>
With the use of QR code, the pairing is established with little
reliance on user judgment, which is arguably safer.
</t>
</section>

<section title="Intra User Pairing and Transitive Pairing">
<t>
There are two usage modes for pairing: inter-user, and intra-user. Users have multiple devices.
The simplest design is to not distinguish between pairing devices belonging to two users,
e.g., Alice's phone and Bob's phone, and devices belonging to the same user, e.g., Alice's 
phone and her laptop. This will most certainly work, but it raises the problem of
transitivity. If Bob needs to interact with Alice, should he install just one pairing for 
"Alice and Bob", or should he install four pairings between Alice phone and laptop and Bob
phone and laptop? Also, what happens if Alice gets a new phone?
</t>
<t>
One tempting response is to devise a synchronization mechanism that will let
devices belonging to the same user share their pairings with other users. But
it is fairly obvious that such service will have to be designed cautiously. The
pairing system relies on shared secrets. It is much easier to understand how
to manage secrets shared between exactly two parties than secrets shared with
an unspecified set of devices.
</t>
<t>
Transitive pairing raises similar issues. Suppose that a group of users wants to collaborate. 
Will they need to set up a fully connected graph of pairings using the simple peer-to-peer
mechanism, or could they use some transitive set, so that if Alice is connected with Bob and 
Bob with Carol, Alice automatically gets connected with Carol? Such transitive mechanisms
could be designed, e.g. using a variation of Needham-Scroeder symmetric key protocol
<xref target="NS1978" />, but it will require some extensive work. Groups can of course use simpler 
solution, e.g., build some star topology.
</t>
<t>
Given the time required, intra-user pairing synchronization mechanisms and transitive pairing
mechanisms are left for further study.
</t>
</section>

<section title="Security Considerations" anchor="securityCons" >
<t>
This document lists a set of security issues that have to be met by pairing protocols, 
but does not specify any protocol.
</t>

</section> <!-- end of security -->


<section title="IANA Considerations" anchor="iana">
<t>
This draft does not require any IANA action.
</t>
</section> <!-- end of iana -->

<section title="Acknowledgments">
<t>
We would like to thank Steve Kent for a detailed early review of an early draft of this document.
Both him and Ted Lemon were influential in the decision to separate the analysis of pairing
requirements from the specification of pairing protocol in <xref target="I-D.ietf-dnssd-pairing" />
</t>
</section>
</middle>

<back>

<references title="Informative References">
       &rfc2104;
       &rfc5705;
       &rfc6151;
       &rfc6189;
       &I-D.ietf-dnssd-pairing;
       &I-D.ietf-dnssd-privacy;
       &I-D.miers-tls-sas;

<reference anchor="NR11" target="">
  <front>
    <title>Authentication protocols based on low-bandwidth unspoofable channels: a comparative survey</title>
    <author initials="L." surname="Nguyen" fullname="Long Hoang Nguyen">
      <organization/>
    </author>
    <author initials="A." surname="Roscoe" fullname="Andrew William Roscoe">
      <organization/>
    </author>
    <date year="2011" month="January"/>
  </front>
<seriesInfo 
name="DOI:"
value="10.3233/JCS-2010-0403" />
<seriesInfo 
name="Journal of Computer Security,"
value="Volume 19 Issue 1, Pages 139-201" />
</reference>

<reference anchor="KFR09" target="">
  <front>
    <title>Usability and Security of Out-Of-Band Channels in Secure Device Pairing Protocols</title>
    <author initials="R." surname="Kainda" fullname="Ronald Kainda">
      <organization/>
    </author>
    <author initials="I." surname="Flechais" fullname="Ivan Flechais">
      <organization/>
    </author>
    <author initials="A." surname="Roscoe" fullname="Andrew William Roscoe">
      <organization/>
    </author>
    <date year="2009" month="January"/>
  </front>
<seriesInfo 
name="DOI:" value="10.1145/1572532.1572547" />
<seriesInfo 
name="SOUPS 09,"
value="Proceedings of the 5th Symposium on Usable Privacy and Security, Mountain View, CA" />
</reference>

<reference anchor="USK11" target="">
  <front>
    <title>Pairing devices for social interactions: a comparative usability evaluation </title>
    <author initials="E." surname="Uzun" fullname="Ersin Uzun">
      <organization/>
    </author>
    <author initials="N." surname="Saxena" fullname="Nitesh Saxena">
      <organization/>
    </author>
    <author initials="A." surname="Kumar" fullname="Arun Kumar">
      <organization/>
    </author>
    <date year="2011" month="May"/>
  </front>
<seriesInfo 
name="DOI:"
value="10.1145/1978942.1979282" />
<seriesInfo 
name="Proceedings of the International Conference on Human Factors in Computing Systems,"
value="CHI 2011, Vancouver, BC, Canada" />
</reference>


<reference anchor="XKCD936" target="https://www.xkcd.com/936/" >
   <front>
    <title>XKCD: Password Strength</title>
    <author initials="R." surname="Munroe" fullname="Randall Munroe">
      <organization/>
    </author>
    <date year="2011"/>
  </front>
</reference>

<reference anchor="BTLEPairing" target="https://developer.bluetooth.org/TechnologyOverview/Pages/LE-Security.aspx">
  <front>
    <title>Bluetooth Low Energy Security Overview</title>
    <author>
      <organization>Bluetooth SIG</organization>
    </author>
    <date year="2016"/>
  </front>
</reference>

<reference anchor="WPS" target="http://www.wi-fi.org/discover-wi-fi/wi-fi-protected-setup">
  <front>
    <title>Wi-Fi Protected Setup</title>
    <author>
      <organization>Wi-Fi Alliance</organization>
    </author>
    <date year="2016"/>
  </front>
</reference>

<reference anchor="NS1978" target="">
  <front>
    <title>. Using encryption for authentication in large networks of computers </title>
    <author initials="R." surname="Needham" fullname="Roger Needham">
      <organization/>
    </author>
    <author initials="M." surname="Schroeder" fullname="Michael Schroeder">
      <organization/>
    </author>
    <date year="1978" month="December" />
  </front>
  <seriesInfo 
name="Communications of the ACM 21 (12):"
value="993-999" />
  <seriesInfo 
name="DOI:"
value="10.1145/359657.359659" />
</reference>

<reference anchor="K17" target="http://nbn-resolving.de/urn:nbn:de:bsz:352-0-422757">
  <front>
    <title>Efficient Privacy-Preserving Configurationless Service Discovery Supporting Multi-Link Networks</title>
    <author initials="D." surname="Kaiser" fullname="Daniel Kaiser">
      <organization/>
    </author>
    <date year="2017"/>
  </front>
</reference>

</references>
</back>
</rfc>
