<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY rfc1033 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1033.xml'>
<!ENTITY rfc1034 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1034.xml'>
<!ENTITY rfc1035 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1035.xml'>
<!ENTITY rfc2045 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2045.xml'>
<!ENTITY rfc2119 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml'>
<!ENTITY rfc2782 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2782.xml'>
<!ENTITY rfc4055 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4055.xml'>
<!ENTITY rfc4075 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4075.xml'>
<!ENTITY rfc4279 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4279.xml'>
<!ENTITY rfc5246 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml'>
<!ENTITY rfc6762 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6762.xml'>
<!ENTITY rfc6763 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6763.xml'>
<!ENTITY rfc7626 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7626.xml'>
<!ENTITY rfc7844 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7844.xml'>
<!ENTITY rfc7858 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7858.xml'>

<!ENTITY I-D.ietf-intarea-hostname-practice PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-intarea-hostname-practice.xml">
<!ENTITY I-D.ietf-dprive-dnsodtls PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dprive-dnsodtls.xml">
<!ENTITY I-D.ietf-tls-tls13 PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-tls-tls13.xml">
<!ENTITY I-D.ietf-dnssd-push PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dnssd-push">

<!ENTITY kw14a PUBLIC ''
   "references/reference.kw14a.xml">
<!ENTITY kw14b PUBLIC ''
   "references/reference.kw14b.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc compact="yes"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>

<!-- Expand crefs and put them inline -->
<?rfc comments='yes' ?>
<?rfc inline='yes' ?>

<rfc category="std"
     docName="draft-kaiser-pairing-00.txt"
     ipr="trust200902">

<front>
    <title abbrev="Device Pairing">
      Device Pairing Using Short Authentication Strings
    </title>

   <author fullname="Christian Huitema" initials="C." surname="Huitema">
      <organization>Microsoft</organization>
      <address>
        <postal>
          <street> </street>
          <city>Redmond</city>
          <code>98052</code>
          <region>WA</region>
          <country>U.S.A.</country>
        </postal>
        <email>huitema@microsoft.com</email>
      </address>
    </author>

   <author fullname="Daniel Kaiser" initials="D." surname="Kaiser">
     <organization>University of Konstanz</organization>
      <address>
        <postal>
          <street> </street>
          <city>Konstanz</city>
          <code>78457</code>
          <region></region>
          <country>Germany</country>
        </postal>
        <email>daniel.kaiser@uni-konstanz.de</email>
      </address>
    </author>

    <date year="2016" />

    <abstract>
        <t>
          This document proposes a device pairing mechanism that establishes a relationship between two devices by
          agreeing on a secret and manually verifying the secret's authenticity.
          Pairing has to be performed only once per pair of devices, as for a re-discovery at any later point in time,
          the exchanged secret can be used for mutual authentication.
        </t>
        <t>
          The proposed pairing method is suited for each application area where human operated devices need to establish a
          relation that allows configurationless and privacy preserving re-discovery at any later point in time.
          Since privacy preserving applications are the main suitors, we especially care about privacy.
        </t>
    </abstract>
</front>

<middle>
<section title="Introduction">
  <t>
  To engage in secure and privacy preserving communication, hosts need to differentiate
  between authorized peers, which must both know about the host's presence and be able to decrypt messages sent by the host,
  and other peers, which must not be able to decrypt the host's messages and ideally should  not be aware of the host's presence.
  The necessary relationship between host and peer can be established by a centralized service, e.g. a certificate  authority,
  by a web of trust, e.g. PGP, or -- without using global identities -- by device pairing.
  </t>
  
  <t>
    This document proposes a device pairing mechanism that provides human operated devices with pairwise authenticated secrets,
    allowing mutual automatic re-discovery at any later point in time along with mutual private authentication.
    We especially care about privacy and user-friendliness.
  </t>

  <t>
    The proposed pairing mechanism consists of three steps needed to establish a relationship between a host and a peer:
  </t>

  <t>
<list style="numbers">
<t>
   Discovery of the peer device. The host needs a means to discover network parameters necessary to establish a connection to the peer.
   The host must not disclose its presence or any other information about the intended pairing to any other peer.
</t>
<t>
  Agreeing on pairing data. The devices have to agree on pairing data, which can be used by both parties at any later point in time to
  generate identifiers for re-discovery and to prove the authenticity of the pairing.
  The pairing data can e.g. be a shared secret agreed upon leveraging a Diffie-Hellman key exchange.
</t>
<t>
  Authenticate pairing data. Since in most cases the messages necessary to agree upon pairing data are send over an insecure channel, 
  the authenticity of these messages has to be guaranteed; otherwise the pairing data is not suited as a means for a later proof of authenticity.
  For the proposed pairing mechanism we use manual interaction to proof the authenticity of the pairing data.
</t>
</list>
</t>

<section title="Requirements">
<t>
  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
  document are to be interpreted as described in <xref target="RFC2119" />.
</t>
</section>
</section>

<section title="Design" anchor="design" >

<t>
  In this section we discuss the design of pairing protocols that use manually verified short authentication strings (SAS).
  Nguyen et al. <xref target="NR11" /> survey these protocols and compare them with respect to the amount of necessary user interaction and
  the computation time needed on the devices.
  The authors state that such a protocol is optimal with respect user interaction if it suffices for users to verify a single b-bit SAS
  while having a one-shot attack success probability of 2^-b.
  Further, n consecutive attacks on the protocol must not have a better success probability then n one-shot attacks.
</t>

<t>
  TODO Should I detail attacks and success probabilities from a theoretical/abstract point of view?
</t>

<t>
  We divide pairing in three parts: discovery, agreement, and authentication, detailed in the following subsections.
</t>

<section title="Discovery">

</section>

<section title="Agreement">
<t>
  Diffie-Hellman
</t>
</section>

<section title="Authentication">
<t>
 Commitment
 SAS: shown on the display and acknowledged by the users.
 SAS: shown by one user and input by the other
</t>
<t>
  Long Authentication String: If devices support QR code scanning, we can use  80bits:
  hash(g^ab || nonce) where.
</t>

</section>


<section title="Intra User Pairing">
  <t>
  Users can pair their own devices in secure (home) networks without any interaction using a special DNS-SD pairing service.
  </t>
  <t>
    USB
  </t>

</section>

<section title="Pairing Data Synchronization">
  <t>
    To make it sufficient for users to pair only one of their devices to one of their friends devices while still
    being able to engage in later communication with all of this friend's devices with any of the own devices,
    we offer the possibility to synchronize pairing data among devices of the same user.
    Pairing data synchronization is performed via a special DNS-SD service (_pdsync._tls).
  </t>
</section>




<section title="Public Authentication Keys">
  <t>
    Should we discuss public authentication keys whose fingerprints are verified during pairing?
</t>
</section>

</section>


<section title="Solution" anchor="solution" >

<t>
  TODO
</t>

<section title="Discovery">
<t>
  DNS-SD <xref target="RFC6763" /> over mDNS <xref target="RFC6762" /> (_pairing._tcp) using an instance name the
  users agreed upon.
</t>
</section>

<section title="Agreement and Authentication">
<t>
IKEv2   (RFC 7296). IKEv2 leverages the SIGMA protocols, which provide various methods of authenticated DH.
</t>
<t>
EKE-EAP (RFC 6124)
</t>
</section>



</section>

<section title="Security Considerations">
<t>
  TODO
</t>

<t>
There are a variety of attacks against pairing systems. They
may result in compromised pairing keys.
the compromised pairing.
</t>
<t>
To mitigate such attacks, nodes MUST be able to quickly revoke
a compromised pairing. This is however not sufficient, as the
compromise of the pairing key could remain undetected for
a long time. For further safety, nodes SHOULD assign a time limit
to the validity of pairings, discard the corresponding keys when
the time has passed, and establish new pairings.
</t>
<t>
This later requirement of limiting the Time-To-Live can raise
doubts about the usability of the protocol. The usability issues
would be mitigated if the initial pairing provided both
a shared secret and the means to renew that secret over time,
e.g. using authenticated public keys.
</t>

</section>


<section title="IANA Considerations" anchor="iana">
<t>
This draft does not require any IANA action.
</t>
</section>

<section title="Acknowledgments">
    <t>
      TODO
    </t>
</section>
</middle>

<back>
<references title="Normative References">
       &rfc2119;
       &rfc6763;
       &rfc6762;
</references>
<references title="Informative References">

<reference anchor="NR11" target="">
  <front>
    <title>Authentication protocols based on low-bandwidth unspoofable channels: a comparative survey</title>
    <author initials="L." surname="Nguyen" fullname="Long Hoang Nguyen">
      <organization/>
    </author>
    <author initials="A." surname="Roscoe" fullname="Andrew William Roscoe">
      <organization/>
    </author>
    <date year="2011"/>
  </front>
</reference>


</references>

</back>
</rfc>
