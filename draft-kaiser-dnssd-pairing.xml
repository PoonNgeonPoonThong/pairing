<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY rfc1033 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1033.xml'>
<!ENTITY rfc1034 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1034.xml'>
<!ENTITY rfc1035 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1035.xml'>
<!ENTITY rfc2045 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2045.xml'>
<!ENTITY rfc2104 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2104.xml'>
<!ENTITY rfc2119 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml'>
<!ENTITY rfc2782 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2782.xml'>
<!ENTITY rfc4055 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4055.xml'>
<!ENTITY rfc4075 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4075.xml'>
<!ENTITY rfc4279 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4279.xml'>
<!ENTITY rfc5705 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5705.xml'>
<!ENTITY rfc5246 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml'>
<!ENTITY rfc6124 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6124.xml'>
<!ENTITY rfc6151 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6151.xml'>
<!ENTITY rfc6189 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6189.xml'>
<!ENTITY rfc6762 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6762.xml'>
<!ENTITY rfc6763 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6763.xml'>
<!ENTITY rfc7296 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7296.xml'>
<!ENTITY rfc7626 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7626.xml'>
<!ENTITY rfc7844 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7844.xml'>
<!ENTITY rfc7858 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7858.xml'>

<!ENTITY I-D.huitema-dnssd-privacy PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.huitema-dnssd-privacy.xml">

<!ENTITY I-D.ietf-intarea-hostname-practice PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-intarea-hostname-practice.xml">
<!ENTITY I-D.ietf-dprive-dnsodtls PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dprive-dnsodtls.xml">
<!ENTITY I-D.ietf-tls-tls13 PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-tls-tls13.xml">
<!ENTITY I-D.ietf-dnssd-push PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dnssd-push">
<!ENTITY I-D.miers-tls-sas PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.miers-tls-sas">


<!ENTITY kw14a PUBLIC ''
   "references/reference.kw14a.xml">
<!ENTITY kw14b PUBLIC ''
   "references/reference.kw14b.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc compact="yes"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>

<!-- Expand crefs and put them inline -->
<?rfc comments='yes' ?>
<?rfc inline='yes' ?>

<rfc category="std"
     docName="draft-kaiser-pairing-00.txt"
     ipr="trust200902">

<front>
    <title abbrev="Device Pairing">
      Device Pairing Using Short Authentication Strings
    </title>

   <author fullname="Christian Huitema" initials="C." surname="Huitema">
      <organization>Microsoft</organization>
      <address>
        <postal>
          <street> </street>
          <city>Redmond</city>
          <code>98052</code>
          <region>WA</region>
          <country>U.S.A.</country>
        </postal>
        <email>huitema@microsoft.com</email>
      </address>
    </author>

   <author fullname="Daniel Kaiser" initials="D." surname="Kaiser">
     <organization>University of Konstanz</organization>
      <address>
        <postal>
          <street> </street>
          <city>Konstanz</city>
          <code>78457</code>
          <region></region>
          <country>Germany</country>
        </postal>
        <email>daniel.kaiser@uni-konstanz.de</email>
      </address>
    </author>

    <date year="2016" />

    <abstract>
        <t>
          This document proposes a device pairing mechanism that establishes a relationship between two devices by
          agreeing on a secret and manually verifying the secret's authenticity.
          Pairing has to be performed only once per pair of devices, as for a re-discovery at any later point in time,
          the exchanged secret can be used for mutual authentication.
        </t>
        <t>
          The proposed pairing method is suited for each application area where human operated devices need to establish a
          relation that allows configurationless and privacy preserving re-discovery at any later point in time.
          Since privacy preserving applications are the main suitors, we especially care about privacy.
        </t>
    </abstract>
</front>

<middle>
<section title="Introduction">
  <t>
  To engage in secure and privacy preserving communication, hosts need to differentiate
  between authorized peers, which must both know about the host's presence and be able to decrypt messages sent by the host,
  and other peers, which must not be able to decrypt the host's messages and ideally should  not be aware of the host's presence.
  The necessary relationship between host and peer can be established by a centralized service, e.g. a certificate  authority,
  by a web of trust, e.g. PGP, or -- without using global identities -- by device pairing.
  </t>
  
  <t>
    This document proposes a device pairing mechanism that provides human operated devices with pairwise authenticated secrets,
    allowing mutual automatic re-discovery at any later point in time along with mutual private authentication.
    We especially care about privacy and user-friendliness.
  </t>

  <t>
    The proposed pairing mechanism consists of three steps needed to establish a relationship between a host and a peer:
  </t>

  <t>
<list style="numbers">
<t>
   Discovery of the peer device. The host needs a means to discover network parameters necessary to establish a connection to the peer.
   The host must not disclose its presence or any other information about the intended pairing to any other peer.
</t>
<t>
  Agreeing on pairing data. The devices have to agree on pairing data, which can be used by both parties at any later point in time to
  generate identifiers for re-discovery and to prove the authenticity of the pairing.
  The pairing data can e.g. be a shared secret agreed upon leveraging a Diffie-Hellman key exchange.
</t>
<t>
  Authenticate pairing data. Since in most cases the messages necessary to agree upon pairing data are send over an insecure channel, 
  the authenticity of these messages has to be guaranteed; otherwise the pairing data is not suited as a means for a later proof of authenticity.
  For the proposed pairing mechanism we use manual interaction to proof the authenticity of the pairing data.
</t>
</list>
</t>

<section title="Requirements">
<t>
  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
  document are to be interpreted as described in <xref target="RFC2119" />.
</t>
</section>
</section>


<section title="Problem statement" anchor="problem" >
<t>
The general pairing requirement is easy to state: establish a trust relation between two entities in a 
secure manner. But details matter, and in this section we explore the detailed requirements that guide
our design.
</t>

<section title="Secure Pairing Over Internet Connections" anchor="securityReq" >
<t>
Many pairing protocols have been already developed, in particular for the
pairing of devices over specific wireless networks. For example, the current BlueTooth 
specifications include a pairing protocol that has evolved over several
revisions towards better security and usability <xref target="BTLEPairing" />.
The Wi-Fi Alliance defined the Wi-Fi Protected Setup process to ease the setup of 
security-enabled Wi-Fi networks in home and small office environments 
<xref target="WPS" />. Other wireless standards have defined or are defining similar
protocols, tailored to specific technologies.
</t>
<t>
This specification defines a pairing protocol that is independent of the underlying 
technology. We simply make the hypothesis that the two parties engaged in the pairing
can discover each other and can exchange establish connections over IP.   
</t>
<t>
TODO: discuss the actual goal. Is it a shared secret or a public key?
</t>
</section>

<section title="Identity Assurance" anchor="verifyId" >
<t>
The parties in the pairing must be able to identify each other. To put it simply, if Alice believes 
that she is establishing a pairing with Bob, she must somehow ensure that the pairing is happening
with Bob, and not with some interloper like Eve or Nessie. Providing this assurance requires care at
the user interface (UI), and also in the design of the protocol.
</t>
<t>
Consider for example an attack in 
which Eve tricks Alice into establishing a pairing, and then pretends to be Bob. Alice must be able 
to discover that something is wrong, and refuse to establish a pairing. To do this,
the UI needs to display the name of the parties beeing paired. (Discuss: what kind of name? Is it 
exchanged a part of the protocol?) At a minimum, the parties engaged in the pairing must be able
to verify the identity under which the pairing is established. 
</t>
</section>

<section title="Adequate user interface" anchor="MITMUIReq" >
<t>
Because the pairing protocol is executed without prior knowledge, it is typically vulnerable to
"Man-in-the-middle" attacks. While Alice is trying to establish a pairing with Bob, Eve positions 
herself in the middle. Instead of getting a pairing between Alice and Bob, Alice gets 
paired with Eve, and Eve with Bob. This requires specific features in the protocol to 
detect man-in-the-middle attacks, and if possible resist them. The reference <xref target="NR11" /> 
analyzes the various proposals to solve this problem, and in this document, we present 
a layman description of these issues in <xref target="MITMCryptoReq" />. The
various protocols proposed in the litterature impose diverse constraints at the UI
interface, which we will review here.
</t>
<section title="Short PIN proved inadequate" >
<t>
The initial Bluetooth pairing protocol relied on four digit PIN. The device to be paired
would display a pin. The user would read that pinand provide it to the pairing device.
The pin would then be used in a Password Authenticated Key Exchange. There was
a similar option in Wi-Fi Protected Setup <xref target="WPS" />. There were
various attacks against the actual protocol. Some were caused by issues
in the protocol, but most of the problems are tied 
to the usability of short PINs.
</t>
<t>
In the reference implementation, the pin is picked at random by the paired device before
the beginning of the exchange. But this requires that the paired device be capable of
generating and displaying a four digit number. It turns out that many devices cannot do
that. For example, an audio headset does not have any display capability. These limited
devices ended up using static pins, with fixed values like "0000" or "0001". 
</t>
<t>
Even when the paired device could display a random pin, that pin will have to be copied
by the user on the pairing device. It turns out that users do not like copying long
series of numbers, and the usability thus dictated that the pins be short -- four digits
in practice. But there is only so much assurance that can be derived from a four digit
key.
</t>
<t>
It is interesting to note that the latest revisions of the Bluetooth Pairing protocol 
<xref target="BTLEPairing" /> do not anymore include the short PIN option. The 
PIN entry methods have been superceded by the simple "just works" method for devices
without displays, and by a procedure based on "short authentication strings" when
displays are available.
</t>

</section>

<section title="Push buttons just work, but are insecure" >
<t>
Some devices are unable to input or display any code. The industry more or less
converged on a "push button" solution. When the button is pushed, devices enter
a "pairing" mode, during which they will accept a pairing request from whatever 
other device connects to them.
</t>
<t>
The Bluetooth Pairing protocol <xref target="BTLEPairing" /> denotes that as 
the "just works" method. It does indeed work, and if the pairing succeeds
the devices will later be able to use the pairing keys to authenticate connections.
However, the procedure does not provide any protection against
MITM attacks during the pairing process. The only protection is that pushing the
button will only allow pairing for a limited time, thus limiting the
opportunities of attacks.
</t>
<t>
As we set up to define a pairing protocol with a briad set of applications,
we cannot limit ourselves to an insecure "push button" method. But we probably
need to allow for a mode of operation that works for input-limited
and display limited devices.
</t>
</section>

<section title="Short range communication" anchor="shortRange" >
<t>
There have been several attempts to define pairing protocols that use "secure
channels." Most of them are based on short range communication systems,
where the short range limits the feasibility for attackers to access the channels.
Example of such limited systems include for example:
</t>
<t>
<list style="symbols" >
<t>
QR codes, displayed on the screen of one device, and read by the camera of the other device.
</t>
<t>
Near Field Communication (NFC) systems, which provides wireless communication with a very short range.
</t>
<t>
Sound systems, in which one systems emits a sequence of sounds or ultrasounds that is picked by the microphone of the other system.
</t>
</list>
</t>
<t>
A common problem with these solutions is that they require special capabilities that may not be present in every device. 
Another problem is that they are often one-way channels. And another problem is that the side channel is not
necessarily secret. QR codes could be read by third parties. Powerful radios antennas might be able to interfere with 
NFC. Sensitive microphones might pick the sounds. We will discuss the specific case of QR codes in <xref target="QRDiscuss" />.
</t>
</section>

<section title="Short authentication strings" >
<t>
The evolving pairing protocols seem to converge towards a "display and compare" method. 
This is in line with academic studies, such as <xref target="KFR09" /> or <xref target="USK11" />.
This point to a very simple scenario:
</t>
<t>
<list style="numbers">
<t>
Alice initiates pairing
</t>
<t>
Bob selects Alice's device from a list.
</t>
<t>
Alice and Bob compare displayed strings that represent a fingerprint of the key.
</t>
<t>
If the strings match, Alice and Bob accept the pairing.
</t>
</list>
</t>
<t>
Most existing pairing protocols display the fingerprint of the key as a 6 or 7 digit
numbers. Usability studies show that gives good results, with little risk that
users mistakenly accept two different numbers as matching. However, the authors of 
<xref target="USK11" /> found that people had more success comparing computer 
generated sentences than comparing numbers. This is in line with the argument in
<xref target="XKCD936" /> to use sequences of randomly chosen common words as passwords. 
On the other hand, standardizing strings is more complicated than standardizing numbers.
We would need to specify a list of common words, and the process to go from a binary 
fingerprint to a set of words. We would need to be concerned with internationalization 
issues, such as using different lists of words in German and in English. This could
require negotiation of word lists or languages inside the pairing protocols. 
</t>
<t>
In contrast, numbers are easy to specify, as in "take a 20 bit number and 
display it as an integer using decimal notation."
</t>

</section>

</section>

<section title="Resist cryptographic attacks" anchor="MITMCryptoReq" >
<t>
It is tempting to believe that once two peers are connected, they could create
a secret with a few simple steps, such as for example exchange two nonces, 
hash the concatenation of this nonces with the shared secret, display
a short authentication string composed of a short version of that hash 
on each device, and verify that that the two values match. The sequence
of messages would be something like:
</t>
<t>
<figure>
<artwork>
    Alice                       Bob
    g^xA --&gt;
                           &lt;-- g^xB
    nA --&gt;
                              &lt;-- nB
    Computes              Computes
    s = g^xAxB            s = g^xAxB
    h = hash(s|nA|nB)     h = hash(s|nA|nB)
    Displays short        Displays short
    version of h          version of h
</artwork>
</figure>
</t>
<t>
If the two short hashes match, Alice and Bob are supposedly assured that
they have computed the same secret, but there is a problem.
The exchange may not deter a smart attacker
in the middle. Let's redraw the same message flow, this time involving Eve:
</t>
<t>
<figure>
<artwork>
    Alice                Eve                Bob
    g^xA --&gt;
                         g^xA'--&gt;
                                        &lt;-- g^xB
                      &lt;--g^xB'
    nA --&gt;
                         nA --&gt; 
                                          &lt;-- nB
                       Picks nB'
                       smartly
                      &lt;--nB'
    Computes                             Computes
    s' = g^xAxB'                           s" = g^xA'xB
    h' = hash(s|nA|nB')                    h" = hash(s"|nA|nB)
    Displays short                       Displays short
    version of h'                        version of h"
</artwork>
</figure>
</t>
<t>
Let's now assumes that to pick the nonce nB' smartly, Eve runs the following
algorithm:
</t>
<t>
<figure>
<artwork>
    s' = g^xAxB'
    s" = g^xA'xB
    repeat
       pick a new version of nB'
       h' = hash(s|nA|nB')
       h" = hash(s"|nA|nB)
    until the short version of h' 
    matches the short version of h"
</artwork>
</figure>
</t>
<t>
Of course, running this algorithm will require in theory as many iterations as
the possible values of the short hash. But hash algorithms are fast, and it
is possible to try millions of values in less than a second. If the short
string is made up of fewer than 6 digits, Eve will find a matching nonce 
quickly, and Alice and Bob will hardly notice the delay. Even if the 
matching string is as long as 8 letters, Eve will probably find a value
where the short versions of h' and h" are close enough, e.g. start and end
with the same two or three letters. Alice and Bob may well be fooled.
</t>
<t>
The classic solution to such problems is to "commit" the value of the hash
before sending it. In the modified exchange, Alice and Bob exchange a secure
hash of their nonces before sending the actual value:
</t>
<t>
<figure>
<artwork>
    Alice                       Bob
    g^xA --&gt;
                            &lt;-- g^xB

    Computes              Computes
    s = g^xAxB            s = g^xAxB
    h_a = hash(s|nA) --&gt;
                              &lt;-- nB
    nA --&gt;
                          verifies h_a == hash(s|nA)
    Computes              Computes
    h = hash(s|nA|nB)     h = hash(s|nA|nB)
    Displays short        Displays short
    version of h          version of h
</artwork>
</figure>
</t>
<t>
Alice will only disclose nA after
having confirmation from Bob that hash(nA) has been received.
At that point, Eve has a problem. She can still forge the values of the nonces
but she needs to pick the nonce nA' before the actual value of nA has been 
disclosed. On first sight, it seems that once she has committed by sending
hash(nA'), it will be impossible to send anything but the nA'. Eve would
still have a random chance of fooling Alice and Bob, but it will be a very
small chance: one in million if the short authentication string is made of
6 digits, even fewer if that string is longer. 
</t>
<t>
Nguyen et al. <xref target="NR11" /> survey these protocols and compare them with respect to the amount of necessary user interaction and
  the computation time needed on the devices.
  The authors state that such a protocol is optimal with respect user interaction if it suffices for users to verify a single b-bit SAS
  while having a one-shot attack success probability of 2^-b.
  Further, n consecutive attacks on the protocol must not have a better success probability then n one-shot attacks.
</t>
<t>
There is still a theoretical problem, if Eve has somehow managed to 
"crack" the hash function. We build some "defense in depth" by 
some simple measures. In the design presented above, the hash "h_a"
depends of the shared secret "s", which acts as a "salt" and reduces
the effectiveness of potential attacks based on pre-computed 
catalogs. For simplicity, the design used a simple concatenation 
mechanism, but we could instead use a keyed-hash message authentication 
code (HMAC, <xref target="RFC2104"/>, <xref target="RFC6151"/>), using 
the shared secret as a key, since the HMAC construct has
proven very robust over time. Then, we can constrain the size of
the random numbers to be exactly the same as the output of the hash 
function. Hash attacks often require padding the input string with
arbitrary data; restraining the size limits the likelyhood of such 
padding.
</t>
</section>

<section title="Privacy Requirements" >
<t>
Pairing exposes a relation between several devices and their owners. Adversaries may
attempt to collect this information, for example in an attempt to track 
devices, their owners, or their "social graph." It is often argued that
pairing could be performed in a safe place, from which adversaries are assumed 
absent, but experience shows that such assumptions are often misguided.
It is much safer to acknowledge the privacy ssues and design the pairing
process accordingly.
</t>
<t>
In order to start the pairing process, devices must first discover each other.
We do not have the option of
using the private discovery protocol <xref target="I-D.huitema-dnssd-privacy" /> 
since the privacy of that protocol depends on the pre-existing pairing. 
In the simplest design, 
one of the devices will announce a "friendly name" using DNS-SD. 
Adversaries could monitor the discovery protocol, and record that name.
An alternative would for one device to announce a random name, and communicate
it to the other device via some private channel. There is an obvious
tradeoff here: friendly names are easier to use but less private than
random names. We anticipate that different users will choose different
tradeoffs, for example using friendly names if they assume that
the environment is "safe," and using random names in public places.
</t>
<t>
When the pairing process is executed, the two devices will establish a connection,
establish and validate a pairing secret. As discussed in <xref target="MITMUIReq" />,
we have to assume that adversaries can mount MITM attacks. The pairing 
protocol can detect such attacks and resit them, but the attackers will
have access to all messages exchanged before validation
is performed. It is important to not exchange any privacy sensitive information
before that validation. This includes, for example, the identities of the
parties or their public keys.
</t>

</section>

<section title="Using TLS" >
<t>
The pairing algorithms typically combine the establishment of a shared
secret through an [EC]DH exchange, with the verification of that secret
through display and comparisons of "Short Authentication String" (SAS).
As explained in <xref target="MITMCryptoReq" />, the
secure comparison requires a "commit before disclose" mechanism.
</t>
<t>
We have three possible designs: create a pairing algorithm from scratch,
specifying our own crypto exchanges; use an [EC]DH version of TLS to
negotiate a shared secret, export the key to the application as specified 
in <xref target="RFC5705" />, and implement
the "commit before disclose" and SAS verification as part of the pairing
application; or, use TLS, integrate the "commit before disclose" and SAS
verification as TLS extensions, and export the verified key to the
application as specified 
in <xref target="RFC5705" />.
</t>
<t>
Creating an algorithm from scratch is probably a bad idea. We would need to
reinvent a lot of the negotiation capabilities that are part of TLS, not
to mention algorithm agility, post quantum, and all that sort of things. 
It is thus pretty clear that we should use TLS.
</t>
<t>
It turns out that there was already an attempt to define 
SAS extensions for TLS (<xref target="I-D.miers-tls-sas" />). 
It is a very close match
to our third design option, full integration of SAS in TLS,
but the draft has expired, and there does not seem to be
any support for the SAS options in the common TLS packages.
</t>
<t>
In our design, we will choose the middle ground option -- use TLS for
[EC]DH,
and implement the SAS verification as part of the pairing application.
This minimizes dependencies on TLS packages to the availability
of a key export API following <xref target="RFC5705" />.
We will need to specify the hash algorithm used for the SAS
computation and validation, which carries some of the issues
associated with "designing our own crypto." One
solution would be to use the same hash algorithm negotiated by
the TLS connection, but common TLS packages do not not always 
make this algorithm identifier available
through standard APIs. A fallback solution is to
specify a state of the art keyed MAC algorithm.
</t>
</section>

<section title="QR codes" anchor="QRDiscuss" >
<t>
In <xref target="shortRange" />, we reviewed a number of short range 
communication systems that can be used to facilitate pairing. Out of these,
QR codes stand aside because most devices that can display a short
string can also display the image of a QR code, and because many
pairing scenarios involve cell phones equipped with cameras capable of
reading a QR code.
</t>
<t>
QR code could be particularly useful when starting discovery. QR code can 
encode an alphanumeric string, which could for example encode the
selected the chosen name of the pairing service. This would enable automatic
discovery, and would be easier to use than reading 
the random name of the day and matching it against the results of DNS-SD.
</t>
<t>
In addition to the instance name, the QR code could also encode a simple
secret. This may not be sufficient to guarantee the secrecy of the
pairing service, since adversaries might be able to see the QR code,
but it could improve the security of the initial Diffie-Hellman exchange.
For example, it could allow usage of TLS with ECDH/PSK, which is 
arguably harder to intercept than anonymous ECDH, or than variant using 
a well known password. 
</t>
<t>
QR codes may or may not be useful in the verification phase. Scanning a QR code
may not be much more efficient than visual verification of a short string. The 
user has to take a picture of the QR code, which is arguably not 
simpler than just "look at the number on the screen and tell me whether it is 
the same as yours."
</t>
<t>
If the case of a man-in-the-middle attack, the evaluation of the QR code will fail. 
The "client" that took the picture will know that, but the "server" will not. The 
user will still need to click some "Cancel" button on the server, which means that
the process will not be completely automated.
</t>

</section>

</section> <!-- end of problem statement -->

<section title="User Experience Design" anchor="design" >

<t>
In this section we discuss the design of pairing protocols that use manually 
verified short authentication strings (SAS), focusing on the user
experience. We will make provision for the optional usage of QR codes.
</t>

<t>
  We divide pairing in three parts: discovery, agreement, and authentication, detailed in the following subsections.
</t>

<section title="Discovery">
<t>
During the discovery phase, the client will find the server. There are two posible experiences depending of whether
QR codes are supported or not. If QR code is supported, the discovery proceeds as follow:
</t>
<t>
<list style="numbers">
<t>
The server displays a QR code containing the its chosen instance name. 
</t>
<t>
The client scans the QR code, and discovery is performed automatically, without
further client interaction.
</t>
</list>
</t>
<t>
If QR codes are not supported, the discovery will require some user interaction:
</t>
<t>
<list style="numbers">
<t>
The server displays its chosen instance name on its screen.  
</t>
<t>
The client performs a discovery of all the "pairing" servers
available on the local network. This may result in the discovery
of several servers.
</t>
<t>
The client user selects from the list of available servers the instance 
name that matches the name displayed by the server.
</t>
</list>
</t>
</section>

<section title="Agreement">
<t>
Once the server has been selected, the client connects to it without
further user intervention. Client and server exchange the required 
messages, and both display a "short authentication string", normally 
a number encoded over up to 7 decimal digits.
</t>
<t>
The users are asked to validate the pairing by comparing the values
of the numbers. If they match, each user enters an agreement, for example 
by pressing a button labelled "OK". If they do not match, each user
should cancel the pairing, for example 
by pressing a button labelled "CANCEL". 
</t>
</section>

<section title="Authentication">
<t>
Once the agreement has been performed, each device displays the 
"real" name of the other device, as exchanged through the pairing 
protocol. Each user verifies that the name matches what they expect.
If the names are validated, each user approves the pairing, which will
then be remembered.
</t>

</section>


<section title="Intra User Pairing">
  <t>
  Users can pair their own devices in secure (home) networks without any interaction using a special DNS-SD pairing service.
  </t>
  <t>
    USB
  </t>

</section>

<section title="Pairing Data Synchronization">
  <t>
    To make it sufficient for users to pair only one of their devices to one of their friends devices while still
    being able to engage in later communication with all of this friend's devices with any of the own devices,
    we offer the possibility to synchronize pairing data among devices of the same user.
    Pairing data synchronization is performed via a special DNS-SD service (_pdsync._tls).
  </t>
</section>




<section title="Public Authentication Keys">
  <t>
    Should we discuss public authentication keys whose fingerprints are verified during pairing?
</t>
</section>

</section>


<section title="Solution" anchor="solution" >

<t>
In the proposed pairing protocol, one of the devices acts as a "server", and the other acts as a "client". 
The server will expose a "pairing service". The client will discover the service instance during the
discovery phase, as explained in <xref target="discoverSpec"/>. The pairing service itself is specified 
in <xref target="serviceSpec" />.

</t>

<section title="Discovery" anchor="discoverSpec" >
<t>
The discovery uses DNS-SD <xref target="RFC6763" /> over mDNS <xref target="RFC6762" />.
The pairing service is identified in DNS SD as "_pairing._tcp".
</t>
<t>
When the pairing service starts, the server starts publishing the chosen instance name.
The client will discover that name and the corresponding connection parameters.
</t>
</section>

<section title="Agreement and Authentication" anchor="serviceSpec">
<t>
<xref target="RFC7296" />. IKEv2 leverages the SIGMA protocols, which provide various methods of authenticated DH.
</t>
<t>
  <xref target="RFC6124" />. EAP-EKE
</t>
<t>
<xref target="RFC6189" />. ZTRP uses a commited DH exchange pairing method
</t>


<t>
  Most efficient with respect to both, minimizing user interactoin (meaning minimizing the SAS that has the be veriyfied) and
  the calculations the device has to be performed, is the improved Hoepman protocol <xref target="NR11" /> :
</t>

<t>
<figure>
<artwork>
  A -> B : longhash(A, g^a)
  B -> A : g^b
  A -> B : g^a
  A (manual auth) B: shorthash(g^ab)
</artwork>
</figure>
</t>

</section>



</section>

<section title="Security Considerations">
<t>
  TODO
</t>

<t>
There are a variety of attacks against pairing systems. They
may result in compromised pairing keys.
the compromised pairing.
</t>
<t>
To mitigate such attacks, nodes MUST be able to quickly revoke
a compromised pairing. This is however not sufficient, as the
compromise of the pairing key could remain undetected for
a long time. For further safety, nodes SHOULD assign a time limit
to the validity of pairings, discard the corresponding keys when
the time has passed, and establish new pairings.
</t>
<t>
This later requirement of limiting the Time-To-Live can raise
doubts about the usability of the protocol. The usability issues
would be mitigated if the initial pairing provided both
a shared secret and the means to renew that secret over time,
e.g. using authenticated public keys.
</t>

</section>


<section title="IANA Considerations" anchor="iana">
<t>
This draft does not require any IANA action.
</t>
</section>

<section title="Acknowledgments">
    <t>
      TODO
    </t>
</section>
</middle>

<back>
<references title="Normative References">
       &rfc2119;
       &rfc5705;
       &rfc6763;
       &rfc6762;
</references>
<references title="Informative References">
       &rfc2104;
       &rfc6124;
       &rfc6151;
       &rfc6189;
       &rfc7296;
       &I-D.huitema-dnssd-privacy;
       &I-D.miers-tls-sas;

<reference anchor="NR11" target="">
  <front>
    <title>Authentication protocols based on low-bandwidth unspoofable channels: a comparative survey</title>
    <author initials="L." surname="Nguyen" fullname="Long Hoang Nguyen">
      <organization/>
    </author>
    <author initials="A." surname="Roscoe" fullname="Andrew William Roscoe">
      <organization/>
    </author>
    <date year="2011"/>
  </front>
</reference>

<reference anchor="KFR09" target="">
  <front>
    <title>Authentication protocols based on low-bandwidth unspoofable channels: a comparative survey</title>
    <author initials="R." surname="Kainda" fullname="Ronald Kainda">
      <organization/>
    </author>
    <author initials="I." surname="Flechais" fullname="Ivan Flechais">
      <organization/>
    </author>
    <author initials="A." surname="Roscoe" fullname="Andrew William Roscoe">
      <organization/>
    </author>
    <date year="2009"/>
  </front>
</reference>

<reference anchor="USK11" target="">
  <front>
    <title>. Pairing devices for social interactions: a comparative usability evaluation </title>
    <author initials="E." surname="Uzun" fullname="Ersin Uzun">
      <organization/>
    </author>
    <author initials="N." surname="Saxena" fullname="Nitesh Saxena">
      <organization/>
    </author>
    <author initials="A." surname="Kumar" fullname="Arun Kumar">
      <organization/>
    </author>
    <date year="2009"/>
  </front>
</reference>


<reference anchor="XKCD936" target="https://www.xkcd.com/936/" >
   <front>
    <title>XKCD: Password Strength</title>
    <author initials="R." surname="Munroe" fullname="Randall Munroe">
      <organization/>
    </author>
    <date year="2011"/>
  </front>
</reference>

<reference anchor="BTLEPairing" target="https://developer.bluetooth.org/TechnologyOverview/Pages/LE-Security.aspx">
  <front>
    <title>Bluetooth Low Energy Security Overview</title>
    <author>
      <organization>Bluetooth SIG</organization>
    </author>
    <date year="2016"/>
  </front>
</reference>

<reference anchor="WPS" target="http://www.wi-fi.org/discover-wi-fi/wi-fi-protected-setup">
  <front>
    <title>Wi-Fi Protected Setup</title>
    <author>
      <organization>Wi-Fi Alliance</organization>
    </author>
    <date year="2016"/>
  </front>
</reference>
</references>

</back>
</rfc>
