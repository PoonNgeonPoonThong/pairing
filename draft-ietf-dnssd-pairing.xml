<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY rfc1033 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1033.xml'>
<!ENTITY rfc1034 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1034.xml'>
<!ENTITY rfc1035 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1035.xml'>
<!ENTITY rfc2045 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2045.xml'>
<!ENTITY rfc2104 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2104.xml'>
<!ENTITY rfc2119 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml'>
<!ENTITY rfc2782 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2782.xml'>
<!ENTITY rfc4055 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4055.xml'>
<!ENTITY rfc4075 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4075.xml'>
<!ENTITY rfc4279 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4279.xml'>
<!ENTITY rfc5246 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml'>
<!ENTITY rfc5705 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5705.xml'>
<!ENTITY rfc5246 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml'>
<!ENTITY rfc6124 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6124.xml'>
<!ENTITY rfc6151 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6151.xml'>
<!ENTITY rfc6189 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6189.xml'>
<!ENTITY rfc6762 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6762.xml'>
<!ENTITY rfc6763 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6763.xml'>
<!ENTITY rfc7296 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7296.xml'>
<!ENTITY rfc7626 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7626.xml'>
<!ENTITY rfc7844 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7844.xml'>
<!ENTITY rfc7858 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7858.xml'>

<!ENTITY I-D.ietf-dnssd-privacy PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dnssd-privacy.xml">

<!ENTITY I-D.ietf-intarea-hostname-practice PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-intarea-hostname-practice.xml">
<!ENTITY I-D.ietf-dprive-dnsodtls PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dprive-dnsodtls.xml">
<!ENTITY I-D.ietf-tls-tls13 PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-tls-tls13.xml">
<!ENTITY I-D.ietf-dnssd-push PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dnssd-push">
<!ENTITY I-D.miers-tls-sas PUBLIC ''
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.miers-tls-sas">


<!ENTITY kw14a PUBLIC ''
   "references/reference.kw14a.xml">
<!ENTITY kw14b PUBLIC ''
   "references/reference.kw14b.xml">
]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc compact="yes"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>

<!-- Expand crefs and put them inline -->
<?rfc comments='yes' ?>
<?rfc inline='yes' ?>

<rfc category="std"
     docName="draft-ietf-dnssd-pairing-02.txt"
     ipr="trust200902">

<front>
    <title abbrev="Device Pairing">
      Device Pairing Using Short Authentication Strings
    </title>

   <author fullname="Christian Huitema" initials="C." surname="Huitema">
      <organization>Private Octopus Inc.</organization>
      <address>
        <postal>
          <street> </street>
          <city>Friday Harbor</city>
          <code>98250</code>
          <region>WA</region>
          <country>U.S.A.</country>
        </postal>
        <email>huitema@huitema.net</email>
      </address>
    </author>

   <author fullname="Daniel Kaiser" initials="D." surname="Kaiser">
     <organization>University of Konstanz</organization>
      <address>
        <postal>
          <street> </street>
          <city>Konstanz</city>
          <code>78457</code>
          <region></region>
          <country>Germany</country>
        </postal>
        <email>daniel.kaiser@uni-konstanz.de</email>
      </address>
    </author>

    <date year="2017" />

    <abstract>
        <t>
          This document proposes a device pairing mechanism that establishes a relationship between two devices by
          agreeing on a secret and manually verifying the secret's authenticity using an SAS (short authentication string).
          Pairing has to be performed only once per pair of devices, as for a re-discovery at any later point in time,
          the exchanged secret can be used for mutual authentication.
        </t>
        <t>
          The proposed pairing method is suited for each application area where human operated devices need to establish a
          relation that allows configurationless and privacy preserving re-discovery at any later point in time.
          Since privacy preserving applications are the main suitors, we especially care about privacy.
        </t>
    </abstract>
</front>

<middle>
<section title="Introduction" anchor="intro">
  <t>
  To engage in secure and privacy preserving communication, hosts need to differentiate
  between authorized peers, which must both know about the host's presence and be able to decrypt messages sent by the host,
  and other peers, which must not be able to decrypt the host's messages and ideally should  not be aware of the host's presence.
  The necessary relationship between host and peer can be established by a centralized service, e.g. a certificate  authority,
  by a web of trust, e.g. PGP, or -- without using global identities -- by device pairing.
  </t>
  
  <t>
    This document proposes a device pairing mechanism that provides human operated devices with pairwise authenticated secrets,
    allowing mutual automatic re-discovery at any later point in time along with mutual private authentication.
    We especially care about privacy and user-friendliness. This pairing system can provide the pairing secrets
    used in DNSSD Privacy Extensions <xref target="I-D.ietf-dnssd-privacy" />.
    
  </t>

  <t>
    The proposed pairing mechanism consists of three steps needed to establish a relationship between a host and a peer:
  </t>

  <t>
<list style="numbers">
<t>
   Discovering the peer device. The host needs a means to discover network parameters necessary to establish a connection to the peer.
   During this discovery process, neither the host nor the peer must disclose its presence.
</t>
<t>
  Agreeing on pairing data. The devices have to agree on pairing data, which can be used by both parties at any later point in time to
  generate identifiers for re-discovery and to prove the authenticity of the pairing.
  The pairing data can e.g. be a shared secret agreed upon via a Diffie-Hellman key exchange.
</t>
<t>
  Authenticating pairing data. Since in most cases the messages necessary to agree upon pairing data are send over an insecure channel, 
  means that guarantee the authenticity of these messages are necessary;
  otherwise the pairing data is in turn not suited as a means for a later proof of authenticity.
  For the proposed pairing mechanism we use manual authentication involving an SAS 
  (short authentication string) to proof the authenticity of the pairing data.
</t>
</list>
</t>
<section title="Requirements">
<t>
  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
  document are to be interpreted as described in <xref target="RFC2119" />.
</t>
</section>

<section title="Document Organization" >
<t>
NOTE TO RFC EDITOR: remove or rewrite this section before publication.
</t>
<t>
The original version of this document was organized in two parts. The first part presented the pairing need, 
the list of requirements that shall be met. This first part was informational in nature. The second part, 
composed the actual specification of the protocol. 
</t>
<t>
In his early review, Steve Kent observed that the style of the first part seems inappropriate for a standards track document,
and suggested that the two parts should be split into two documents, the first part becoming an 
informational document, and the second focusing on standard track specification of the protocol, making reference to the informational document as appropriate.
We, the authors, will seek working group approval before performing this split.
</t>
<t>
The DNS-SD working group approved this split during its meeting in Prague in July 2017. This version of
the document implements the split, only retaining the specification part.
</t>
</section>

</section> <!-- end of introduction -->

<section title="Protocol Specification" anchor="solution" >
<t>
In the proposed pairing protocol, one of the devices acts as a "server", and the other acts as a "client". 
The server will publish a "pairing service". The client will discover the service instance during the
discovery phase, as explained in <xref target="discoverSpec"/>. The pairing service itself is specified 
in <xref target="serviceSpec" />.
</t>
<t>
We divide pairing in three parts: discovery, agreement, and authentication,
detailed in the following subsections.
</t>


<section title="Discovery" anchor="discoverSpec" >
<t>
The goal of the discovery phase is establishing a connection, which is later used to
exchange the pairing data, between the two devices that are about to be paired
in an IP network without any prior knowledge and without publishing any private information.
</t>
<t>
The discovery uses When the pairing service starts, the server .
The client will discover that name and the corresponding connection parameters.
</t>
<t>
The discovery proceeds as follows:
</t>
<t>
<list style="numbers">
<t>
The server starts publishing the chosen instance name and displays it on the server's screen.
The instance name is published according to DNS-SD <xref target="RFC6763" /> over mDNS <xref target="RFC6762" />.
The pairing service is identified in DNS SD as "_pairing._tcp".
</t>
<t>
The client performs a discovery of all the instances of the pairing service
available on the local network. This may result in the discovery
of several instance names.
</t>
<t>
Among these available instance names, the client's user 
selects the name that matches the name displayed by the server.
</t>
<t>
Per DNS-SD, the client then retrieves the SRV records of the selected instance,
selects one of the discovered servers, retrieves its A or AAAA records, and
establishes the connection.
</t>
</list>
</t>
</section> <!-- End of discovery spec -->

<section title="Agreement on a shared secret" anchor="agreementSpec">
<t>
Once the server has been selected at the end of the discovery phase, the client connects to it without 
further user intervention.
Client and server use this connection for exchanging data that allows them to agree on a shared secret
by using TLS and a key exporter.
</t>
<t>
Devices implementing the service MUST 
support TLS 1.2 <xref target="RFC5246" />, and MAY negotiate TLS 1.3 when 
it becomes available.
When using TLS, the client and server MUST negotiate a ciphersuite
providing forward secrecy (PFS), and strong encryption (256 bits symmetric 
key). All implementations using TLS 1.2 MUST be able to negotiate
the cipher suite TLS_DH_anon_WITH_AES_256_CBC_SHA256.
</t>
<t>
Once the TLS connection has been established, each party extracts the pairing secret 
S_p from the connection context per <xref target="RFC5705" />, using the following 
parameters:
</t>
<t>
<list style="hanging" hangIndent="6">
<t hangText="Disambiguating label string:" >
"PAIRING SECRET"
</t>
<t hangText="Context value:" >
empty.
</t>
<t hangText="Length value:">
32 bytes (256 bits).
</t>
</list>
</t>
<t>
The secret "S_p" will be authenticate in the authentication part of the protocol.
</t>
</section> <!-- End of agreement spec -->

<section title="Authentication" anchor="serviceSpec">
<t>
The pairing protocol implemented on top of TLS allows the users to authenticate
the shared secret established in the "Agreement" phase, and to minimize the risk
of interference by a third party like a "man-in-the-middle". 
The pairing protocol is built using TLS. The following description uses the
presentation language defined in section 4 of <xref target="RFC5246" />.
The protocol uses five message types, defined in the following enum:
</t>
<t>
<figure>
<artwork>
enum {
   ClientHash(1),
   ServerRandom(2),
   ClientRandom(3),
   ServerSuccess(4),
   ClientSuccess(5)
} PairingMessageType;
</artwork>
</figure>
</t>
<t>
Once S_p has been obtained, the client picks a random number R_c, exactly 32 bytes 
long. The client then selects a hash algorithm, which SHOULD be the same algorithm as 
negotiated for building the PRF in the TLS connection. If there is no suitable API to 
retrieve that algorithm, the client MAY use SHA256 instead. The client then computes 
the hash value H_c as:
</t>
<t>
<list>
<t>
H_c = HMAC_hash(S_p, R_c)
</t>
<t>
Where "HMAC_hash" is the HMAC function constructed with the selected algorithm.
</t>
</list>
</t>
<t>
The client transmits the selected hash function and the computed value of H_c 
in the Client Hash message, over the TLS connection:
</t>
<t>
<figure>
<artwork>
struct {
   PairingMessageType messageType;
   hashAlgorithm hash;
   uint8 hashLength;
   opaque H_c[hashLength];
} ClientHashMessage;
</artwork>
</figure>
</t>
<t>
<list style="hanging" hangIndent="6">
<t hangText="messageType" >
Set to "ClientHash".
</t>
<t hangText="hash" >
The code of the selected hash algorithm, per definition of HashAlgorithm in section 7.4.1.1.1 of 
<xref target="RFC5246" />.
</t>
<t hangText="hashLength" >
The length of the hash H_c, which MUST be consistent with the selected algorithm "hash".
</t>
<t hangText="H_c" >
The value of the client hash.
</t>
</list>
</t>
<t>
Upon reception of this message, the server stores its value. The server picks a random number R_s,
exactly 32 bytes long, and transmits it to the client in the server random message, over the TLS connection:
</t>
<t>
<figure>
<artwork>
struct {
   PairingMessageType messageType;
   opaque R_s[32];
} ServerRandomMessage;
</artwork>
</figure>
</t>
<t>
<list style="hanging" hangIndent="6">
<t hangText="messageType" >
Set to "ServerRandom".
</t>
<t hangText="R_s" >
The value of the random number chosen by the server.
</t>
</list>
</t>
<t>
Upon reception of this message, the client discloses its own random
number by transmitting the client random message:
</t>
<t>
<figure>
<artwork>
struct {
   PairingMessageType messageType;
   opaque R_c[32];
} ClientRandomMessage;
</artwork>
</figure>
</t>
<t>
<list style="hanging" hangIndent="6">
<t hangText="messageType" >
Set to "ClientRandom".
</t>
<t hangText="R_c" >
The value of the random number chosen by the client.
</t>
</list>
</t>
<t>
Upon reception of this message, the server verifies that the 
number R_c hashes to the previously received value H_c. If
the number does not match, the server MUST abandon the pairing
attempt and abort the TLS connection.
</t>
<t>
At this stage, both client and server can compute the short
hash SAS as:
</t>
<t>
<list>
<t>
SAS = first 20 bits of HMAC_hash(S_p, R_c + R_s)
</t>
<t>
Where "HMAC_hash" is the HMAC function constructed with the hash
algorithm selected by the client in the ClientHashMessage.
</t>
</list>
</t>
<t>
Both client and server display the SAS as a 7 digit decimal integer, 
including leading zeroes, and ask the user to compare the values. 
If the SASes match, each user enters an agreement, for example by pressing a button 
labeled "OK", which results in the pairing being remembered.
If they do not match, each user should cancel the pairing, for example by pressing a 
button labeled "CANCEL". 
</t>
<t>
If the values do match and both users agree, the protocol continues with the
exchange of names, both server and client announcing their own preferred
name in a Success message
</t>
<t>
<figure>
<artwork>
struct {
   PairingMessageType messageType;
   uint8 nameLength;
   opaque name[nameLength];
} ClientSuccessMessage;
</artwork>
</figure>
</t>
<t>
<list style="hanging" hangIndent="6">
<t hangText="messageType" >
Set to "ClientSuccess" if transmitted by the client, "ServerSuccess" if by the server.
</t>
<t hangText="nameLength" >
The length of the string encoding the selected name.
</t>
<t hangText="name" >
The selected name of the client or the server, encoded as a string of UTF8 characters.
</t>
</list>
</t>
<t>
After receiving these messages, client and servers can orderly close the TLS connection, 
terminating the pairing exchange.
</t>
</section>

</section> <!-- end of solution -->

<section title="Optional use of QR codes">
<t>
When QR codes are supported, the discovery process can be independent of DNS-SD, because 
QR codes allow the transmission of a sufficient amount of data. The agreement process
can also be streamlined by the scanning of a second QR code.
</t>
<section title="Discovery using QR Codes" anchor="discoverSpecQR" >
<t>
If QR code scanning is available as out-of-band channel, the discovery data is
directly transmitted via QR codes instead of DNS-SD over mDNS. 
Leveraging QR codes, the discovery proceeds as follows:
</t>
<t>
<list style="numbers">
<t>
The server displays a QR code containing the connection data otherwise found in the SRV and A or AAAA records: 
IPv4 or IPv6 address, port number, and optionally host name. 
</t>
<t>
The client scans the QR code retrieving the necessary information for establishing a connection to the server.
</t>
</list>
</t>
<t>
[[TODO: We should precisely specify the data layout of this QR code.
It could either be the wire format of the corresponding resource records (which would be easier for us),
or a more efficient representation. If we chose the wire format, we could use a fixed name as instance name.]]
</t>
</section>

<section title="Agreement with QR Codes" anchor="agreementSpecQR">
<t>
When QR codes are available, the agreement on a shared secret proceeds exactly as in the general case.
</t>
</section>

<section title="Authentication with QR Codes" anchor="serviceSpecQR">
<t>
The availability of QR codes does not change the required network messages or
the computation of the SAS, which will performed exactly as specified in
<xref target="serviceSpec" />, but when QR codes are supported, the SAS may also 
be represented as QR code.
</t>
<t>
In the general case, both client and server display the SAS as a decimal integer,
and ask the user to compare the values. 
If the server supports QR codes, the server displays a QR code encoding
the decimal string representation of the SAS. If the client is capable 
of scanning QR codes, it may scan the value and compare it to the locally
computed value. 
</t>
<t>
Once use agreement has been obtained, the protocol continues as in the 
general case presented in <xref target="serviceSpec" />.
</t>
</section>

</section> <!-- end of optional QR code variant -->

<section title="Security Considerations" anchor="securityCons" >
<t>
We need to consider two types of attacks against a pairing 
system: attacks that occur during the establishment of the 
pairing relation, and attacks that occur after that 
establishment.
</t>

<t>
During the establishment of the pairing system, we are
concerned with privacy attacks and with MitM attacks. Privacy attacks
reveal the existence of a pairing between two devices, which can be used 
to track graphs of relations. MitM attacks result in compromised pairing
keys. The
discovery procedures specified in <xref target="discoverSpec" /> 
and the authentication procedures specified in 
<xref target="serviceSpec" /> are specifically designed to
mitigate such attacks, assuming that the client and user are in close, physical 
proximity and thus a human user can visually acquire and verify the pairing information.
</t>

<t>
The establishment of the pairing results in the creation of a shared
secret. After the establishment of the pairing relation,
attackers who compromise one of the devices could access the shared
secret. This will enable them to either track or spoof the devices. 
To mitigate such attacks, nodes MUST store the secret safely,
and MUST be able to quickly revoke
a compromised pairing. This is however not sufficient, as the
compromise of the pairing key could remain undetected for
a long time. For further safety, nodes SHOULD assign a time limit
to the validity of pairings, discard the corresponding keys when
the time has passed, and establish new pairings.
</t>

</section> <!-- end of security -->


<section title="IANA Considerations" anchor="iana">
<t>
This draft does not require any IANA action.
</t>
</section> <!-- end of iana -->

<section title="Acknowledgments">
<t>
We would like to thank Steve Kent for a detailed early review of this document.
</t>
</section>
</middle>

<back>
<references title="Normative References">
       &rfc2119;
       &rfc5246;
       &rfc5705;
       &rfc6763;
       &rfc6762;
</references>
<references title="Informative References">
       &I-D.ietf-dnssd-privacy;




</references>
</back>
</rfc>
